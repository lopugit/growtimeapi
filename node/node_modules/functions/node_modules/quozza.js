function quozza(text, dbIndex) {
	let query = {
		$search: {
			index: dbIndex,
			compound: {
				should: [
					{
						text: {
							query: text,
							path: "title",
							fuzzy: {
								maxEdits: 2,
								maxExpansions: 1000
							},
							score: {
								boost: {
									value: text.length*2
								}
							}
						}
					}
				]
			}
		}
	}
	let splitText = text.split(" ").filter(subtext => subtext.length)
	let ngrams = []
	splitText.forEach(subtext => {
		ngrams.push({ text: subtext, score: subtext.length*2 })
		ngrams.push(...createNGrams(subtext))
	})

	ngrams.forEach(ngram => {
		if (ngram.text.length >= 1) {
			let maxEdits = 2
			let fuzzy = true
			if (ngram.text.length > 0 && ngram.text.length < 3) {
				fuzzy = false
			} else if (ngram.text.length >= 3 && ngram.text.length < 4) {
				maxEdits = 1
			}
			query.$search.compound.should.push(					
				{
					text: {
						query: ngram.text,
						path: "title",
						fuzzy: fuzzy ? {
							maxEdits: maxEdits,
							maxExpansions: 1000
						} : false,
						score: {
							boost: {
								value:ngram.score
							}
						}
					}
				}
			)
		}
	})
	
	return query
	
}

function createNGrams(text, seen = [], curNGrams = []) {

	let ngrams = []
	for(let i = text.length-1; i > 3; i--) {
		let newNGrams = nGram(i)(text)
		newNGrams = newNGrams.map(ngram => { return { text: ngram, score: text.length + i } })
		newNGrams.forEach(ngram => {
			if(seen.indexOf(ngram.text) < 0){
				ngrams.push(ngram)
				seen.push(ngram.text)
				ngrams.push(...createNGrams(ngram.text, seen, ngrams))
			}
		})
	}
	
	return ngrams
	
}

/**
 * Factory returning a function that converts a value string to n-grams.
 *
 * @param {number} n
 */
function nGram(n) {
  if (
    typeof n !== 'number' ||
    Number.isNaN(n) ||
    n < 1 ||
    n === Number.POSITIVE_INFINITY
  ) {
    throw new Error('`' + n + '` is not a valid argument for `n-gram`')
  }

  return grams

  /**
   * Create n-grams from a given value.
   *
   * @template {string|string[]} T
   * @param {T} [value]
   * @returns {T[]}
   */
  function grams(value) {
    /** @type {T[]} */
    var nGrams = []
    /** @type {number} */
    var index
    /** @type {string|string[]} */
    var source

    if (value === null || value === undefined) {
      return nGrams
    }

    source = value.slice ? value : String(value)
    index = source.length - n + 1

    if (index < 1) {
      return nGrams
    }

    while (index--) {
      // @ts-ignore
      nGrams[index] = source.slice(index, index + n)
    }

    return nGrams
  }
}

// catches all uncaught errors so process never dies
process.on("uncaughtException", function (err) {
  console.log("Caught exception: ", err);
});



module.exports = quozza