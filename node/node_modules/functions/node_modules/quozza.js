function quozza(searchify, dbIndex, paths) {
	let text = searchify.text
	let query = {
		$search: {
			index: dbIndex,
			compound: {
				should: []
			}
		}
	}

	if (searchify.must) {
		query.$search.compound.must = searchify.must
	}

	let splitText = text.split(" ").filter(subtext => subtext.length)
	let ngrams = []
	
	splitText.forEach(subtext => {
		ngrams.push({ text: subtext, score: subtext.length*2 })
		ngrams.push(...createNgrams(subtext))
	})

	ngrams.forEach(ngram => {
		if (ngram.text.length >= 1) {
			appendNgramQuery(ngram, query, paths)
		}
	})
	
	return query
	
}

function appendNgramQuery (ngram, query, paths) {
	let maxEdits = 2
	let textToCheck = ngram.text.replace(/ /g, "")
	let text = true
	let wildcard = true
	if (textToCheck.length > 0 && textToCheck.length < 3) {
		text = false
		wildcard = true
	} else if (textToCheck.length >= 3 && textToCheck.length <= 5) {
		maxEdits = 1
	}
	for (path of paths) {
		console.log(path)
		if (text) {
			query.$search.compound.should.push({
				text: {
					query: ngram.text,
					path: path,
					fuzzy: {
						maxEdits: maxEdits,
						maxExpansions: 1000
					},
					score: {
						boost: {
							value: ngram.score
						}
					}
				}
			})
		}
		if (wildcard) {
			query.$search.compound.should.push({
				wildcard: {
					query: `*${ngram.text}*`,
					path: path,
					allowAnalyzedField: true,
					score: {
						boost: {
							value: ngram.score
						}
					}
				}
			})
		}
	}
}

function createNgrams(text, seen = [], curNgrams = []) {

	let ngrams = []
	for(let i = text.length-1; i > 3; i--) {
		let newNgrams = nGram(i)(text)
		newNgrams = newNgrams.map(ngram => { return { text: ngram, score: text.length + i } })
		newNgrams.forEach(ngram => {
			if(seen.indexOf(ngram.text) < 0){
				ngrams.push(ngram)
				seen.push(ngram.text)
				ngrams.push(...createNgrams(ngram.text, seen, ngrams))
			}
		})
	}
	
	return ngrams
	
}

/**
 * Factory returning a function that converts a value string to n-grams.
 *
 * @param {number} n
 */
function nGram(n) {
  if (
    typeof n !== 'number' ||
    Number.isNaN(n) ||
    n < 1 ||
    n === Number.POSITIVE_INFINITY
  ) {
    throw new Error('`' + n + '` is not a valid argument for `n-gram`')
  }

  return grams

  /**
   * Create n-grams from a given value.
   *
   * @template {string|string[]} T
   * @param {T} [value]
   * @returns {T[]}
   */
  function grams(value) {
    /** @type {T[]} */
    var nGrams = []
    /** @type {number} */
    var index
    /** @type {string|string[]} */
    var source

    if (value === null || value === undefined) {
      return nGrams
    }

    source = value.slice ? value : String(value)
    index = source.length - n + 1

    if (index < 1) {
      return nGrams
    }

    while (index--) {
      // @ts-ignore
      nGrams[index] = source.slice(index, index + n)
    }

    return nGrams
  }
}

// catches all uncaught errors so process never dies
process.on("uncaughtException", function (err) {
  console.log("Caught exception: ", err);
});



module.exports = quozza