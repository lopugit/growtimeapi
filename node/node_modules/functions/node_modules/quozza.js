function quozza(text, dbIndex) {
	let query = {
		$search: {
			index: dbIndex,
			compound: {
				should: [
					createNGramQuery({ text, score: text.length*2 })
				]
			}
		}
	}
	let splitText = text.split(" ").filter(subtext => subtext.length)
	let ngrams = []
	
	splitText.forEach(subtext => {
		ngrams.push({ text: subtext, score: subtext.length*2 })
		ngrams.push(...createNGrams(subtext))
	})

	ngrams.forEach(ngram => {
		if (ngram.text.length >= 1) {
			query.$search.compound.should.push(createNGramQuery(ngram))
		}
	})
	
	return query
	
}

function createNGramQuery (ngram) {
	let maxEdits = 2
	let text = true
	let wildcard = false
	if (ngram.text.length > 0 && ngram.text.length < 3) {
		text = false
		wildcard = true
	} else if (ngram.text.length >= 3 && ngram.text.length < 5) {
		maxEdits = 1
	}
	let ret = {}
	if (text) {
		ret.text = {
			query: ngram.text,
			path: "title",
			fuzzy: {
				maxEdits: maxEdits,
				maxExpansions: 1000
			},
			score: {
				boost: {
					value:ngram.score
				}
			}
		}
	}
	if (wildcard) {
		ret.wildcard = {
			query: `*${ngram.text}*`,
			path: "title",
			allowAnalyzedField: true,
			score: {
				boost: {
					value:ngram.score
				}
			}
		}
	}
	return ret
}

function createNGrams(text, seen = [], curNGrams = []) {

	let ngrams = []
	for(let i = text.length-1; i > 3; i--) {
		let newNGrams = nGram(i)(text)
		newNGrams = newNGrams.map(ngram => { return { text: ngram, score: text.length + i } })
		newNGrams.forEach(ngram => {
			if(seen.indexOf(ngram.text) < 0){
				ngrams.push(ngram)
				seen.push(ngram.text)
				ngrams.push(...createNGrams(ngram.text, seen, ngrams))
			}
		})
	}
	
	return ngrams
	
}

/**
 * Factory returning a function that converts a value string to n-grams.
 *
 * @param {number} n
 */
function nGram(n) {
  if (
    typeof n !== 'number' ||
    Number.isNaN(n) ||
    n < 1 ||
    n === Number.POSITIVE_INFINITY
  ) {
    throw new Error('`' + n + '` is not a valid argument for `n-gram`')
  }

  return grams

  /**
   * Create n-grams from a given value.
   *
   * @template {string|string[]} T
   * @param {T} [value]
   * @returns {T[]}
   */
  function grams(value) {
    /** @type {T[]} */
    var nGrams = []
    /** @type {number} */
    var index
    /** @type {string|string[]} */
    var source

    if (value === null || value === undefined) {
      return nGrams
    }

    source = value.slice ? value : String(value)
    index = source.length - n + 1

    if (index < 1) {
      return nGrams
    }

    while (index--) {
      // @ts-ignore
      nGrams[index] = source.slice(index, index + n)
    }

    return nGrams
  }
}

// catches all uncaught errors so process never dies
process.on("uncaughtException", function (err) {
  console.log("Caught exception: ", err);
});



module.exports = quozza